<!DOCTYPE html>
<html>
<head>
    <title>C++/Qt</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" href="fonts/font.css">
    <link href="images/Qt2.png" rel="shortcut icon" type="image/x-icon">
</head>
<body>
 <div id="site">
    <div id="header">
        <div class="logo"><center><a href="C++.html"  name="C++" title="C++"><img src="images/logo_c.svg" class="logoimg"></a></center></div>
        <div class="logo2"><center><a href="Qt.html"  name="Qt" title="Qt"><img src="images/logo_qt.png" class="logoimg2"></a></center></div>
        <div class="title"><center><a href="index.html"  name="main" title="Головна"><img src="images/title.png" class="titleimg"></a></center></div>
        
    </div>
    <div id="content">
        <div id="menu3">
            <ul>
                <li><a href="type.html">Типи даних</a>
                </li>
                <li><a href="operators.html">Оператори й операції</a>
                </li>
                <li><a href="managing_structures.html">Керуючі структури</a>
                </li>
                <li><a href="cycle.html">Цикли</a>
                </li>
                <li><a href="functions.html">Функції</a>
                </li>
                <li><a href="standart_functions.html">Стандартні Функції</a>
                </li>
                <li><a href="array.html">Масиви []</a>
                </li>
                <li><a href="ptr.html">Вказівники *, Силки&</a>
                </li>
                <li><a href="string.html">Робота зі стрічками</a>
                </li>
                <li><a href="struct.html">Структури</a>
                </li>
                <li><a href="dynamic_struct.html">Динамічні Структури даних</a>
                </li>
                <li><a href="fstream.html">Робота з файлами(Fstream)</a>
                </li>
                <li><a href="template.html">Шаблони функцій</a>
                </li>
                <li><a href="clases.html">ООП Класи</a>
                </li>
                <li><a href="constructors.html">Конструктор і деструктор</a>
                </li>
                <li><a href="peregruzka.html">Перегрузка операцій</a>
                </li>
                <li><a href="nasliduvanya.html">Наслідування</a>
                </li>
                <li><a href="virtual.html">Віртуальні функції</a>
                </li>
                <li><a href="exception.html">Винятки</a>
                </li>
                <li><a href="stl.html">STL</a>
                </li>
            </ul>
       </div>
        <div id="menu4">
            <ul>
                <li><a href="qt_creator.html">Qt Creator</a>
                </li>
                <li><a href="Widgets.html">Віджети та компонування</a>
                </li>
                <li><a href="comp.html">Класи компонування</a>
                </li>
                <li><a href="Modul.html">Модулі Qt</a>
                </li>
                <li><a href="qt_designer.html">Знайомство з Qt Designer</a>
                </li>
                <li><a href="signals.html">Сигнали и слоти</a>
                </li>
                <li><a href="mainwindow.html">Класи главного вікна</a>
                </li>
                </li>
                <li><a href="dialog.html">Діалогові вікна</a>
                </li>
                <li><a href="Modal.html">Модальні немодальні вікна</a>
                </li>
                <li><a href="Menu.html">Створення меню в Qt</a>
                </li>
                <li><a href="qfile.html">Робота з файлами</a>
                </li>
                <li><a href="qdata.html">Клас дати QDate</a>
                </li>
                <li><a href="qtime.html">Клас часу QTime</a>
                </li>

                <li><a href="conteiner.html">Контейнери в Qt</a>
                </li>
                <li><a href="iterator.html">Ітератори</a>
                </li>
                <li><a href="foreach.html">Конструкція foreach</a>
                </li>
                <li><a href="Webkit.html">QtWebKit Guide</a>
                </li>
                <li><a href="sql.html">Модуль QtSql</a>
                </li>
                <li><a href="paint.html">Система малювання</a>
                </li>
                <li><a href="test.html">Тестування в Qt</a>
                </li>
            </ul>
       </div> 
        <div id="wrapper">
            <center><h1>virtual в С++</h1></center>
        <br>
        <p>Поліморфізм часу виконання забезпечується за рахунок використання похідних класів і віртуальних функцій. Віртуальна функція - це функція, оголошена з ключовим словом virtual в базовому класі і перевизначена в одному або в декількох похідних класах. Віртуальні функції є особливими функціями, тому що при виклику об'єкта похідного класу за допомогою покажчика або посилання на нього С ++ визначає під час виконання програми, яку функцію викликати, грунтуючись на типі об'єкта. Для різних об'єктів викликаються різні версії однієї і тієї ж віртуальної функції. Клас, що містить одну або більше віртуальних функцій, називається поліморфним класом (polymorphic class).</p>
        <p>Віртуальна функція оголошується в базовому класі з використанням ключового слова virtual. Коли ж вона переопределяется в похідному класі, повторювати ключове слово virtual немає необхідності, хоча і в разі його повторного використання помилки не виникне.</p>
        <p>В качестве первого примера виртуальной функции рассмотрим следующую короткую программу:</p>
        <p><ex class="ex">&nbsp;&nbsp; // невеликий приклад використання віртуальних функцій &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; #include &lt;iostream.h> &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; class Base { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; public: &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; virtual void who() { // визначення віртуальної функції &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; cout &lt;&lt; *Base\n"; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; class first_d: public Base { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; public: &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; void who() { // визначення who () стосовно first_d &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; cout &lt;&lt; "First derivation\n"; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; class seconded: public Base { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; public: &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; void who() { // визначення who () стосовно second_d &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; cout &lt;&lt; "Second derivation\n*"; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; int main() &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Base base_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Base *p; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; first_d first_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; second_d second_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; p = &base_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; p->who(); // доступ до who класу Base &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; p = &first_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; p->who(); // доступ до who класу first_d &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; p = &second_ob; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; p->who(); // доступ до who класу second_d &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; return 0; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p>Програма видасть наступний результат:</p>
        <p><ex class="ex">&nbsp;&nbsp; Base &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; First derivation &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Second derivation &nbsp;&nbsp;</ex></p>
        <p>Проаналізуємо детальніше цю програму, щоб зрозуміти, як вона працює.</p>
        <p>Як можна бачити, в об'єкті Base функція who () оголошена як віртуальна. Це означає, що ця функція може бути перевизначена в похідних класах. У кожному з класів first_d і second_d функція who () перевизначена. У функції main () визначено три змінні. Першою є об'єкт base_obj, що має тип Base. Після цього оголошений покажчик р на клас Base, потім об'єкти first_obj і second_obj, що відносяться до двох похідним класам. Далі вказівником р присвоєно адресу об'єкта base_objі викликана функція who (). Оскільки ця функція оголошена як віртуальна, то С ++ визначає на етапі виконання, яку з версій функції who () вжити, в залежності від того, на який об'єкт вказує покажчик р. В даному випадку їм є об'єкт типу Base, тому виповнюється версія функції who (), оголошена в класі Base. Потім вказівником р присвоєно адресу об'єкта first_obj. (Як відомо, покажчик на базовий клас може бути використаний для будь-якого похідного класу.) Після того, як функція who () була викликана, С ++ знову аналізує тип об'єкта, на який вказує р, для того, щоб визначити версію функції who ( ), яку необхідно викликати. Оскільки р вказує на об'єкт типу first_d, то використовується відповідна версія функції who (). Аналогічно, коли вказівником р присвоєно адресу об'єкта second_obj, то використовується версія функції who (), оголошена в класі second_d.</p>
        <p>Найбільш поширеним способом виклику віртуальної функції служить використання параметра функції. Наприклад, розглянемо наступну модифікацію попередньої програми:</p>
        <p><ex class="ex">&nbsp;&nbsp; /* Тут посилання на базовий клас використовується для доступу до віртуальної функції * / &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; #include &lt;iostream.h> &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; class Base { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; public: &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; virtual void who() { // визначення віртуальної функції &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; cout &lt;&lt; "Base\n"; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; class first_d: public Base {
 &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; public: &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; void who () { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; // визначення who () стосовно first_d
 &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; cout &lt;&lt; "First derivation\n"; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; class second_d: public Base { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; public: &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; void who() { // визначення who () стосовно second_d  &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; cout &lt;&lt; "Second derivation\n*"; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; // використання в якості параметра посилання на базовий клас &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; void show_who (Base &r) { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; r.who(); &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; int main() { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Base base_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; first_d first_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; second_d second_obj; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; show_who (base_ob j) ; // доступ до who класу Base &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; show_who(first_obj); // доступ до who класу first_d &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; show_who(second_obj); // доступ до who класу second_d &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; return 0; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p>Ця програма виводить на екран ті ж самі дані, що і попередня версія. В даному прикладі функція show_who () має параметр типу посилання на клас Base. У функції main () виклик віртуальної функції здійснюється з використанням об'єктів типу Base, first_d і second_d. Її викликає версія функції who () у функції show_who () визначається типом об'єкта, на який посилається параметр при виклику функції.</p> 
        <p>Ключовим моментом у використанні віртуальної функції для забезпечення поліморфізму часу виконання служить те, що використовується покажчик саме на базовий клас. Поліморфізм часу виконання досягається тільки при виклику віртуальної функції з використанням покажчика або посилання на базовий клас. Однак ніщо не заважає викликати віртуальні функції, як і будь-які інші «нормальні» функції, однак досягти поліморфізму часу виконання на цьому шляху не вдасться.</p>
        <p>На перший погляд перевизначення віртуальної функції в похідному класі виглядає як спеціальна форма перевантаження функції. Але це не так, і термін перевантаження функції не можна застосувати до перевизначення віртуальної функції, оскільки між ними є істотні відмінності. По-перше, функція повинна відповідати прототипу. Як відомо, при перевантаженні звичайної функції число і тип параметрів повинні бути різними. Якщо ви перевизначаєте віртуальної функції інтерфейс функції повинен в точності відповідати прототипу. Якщо ж такої відповідності немає, то така функція просто розглядається як перевантажена і вона втрачає свої віртуальні властивості. Крім того, якщо відрізняється тільки тип значення, то видається повідомлення про помилку. (Функції, що відрізняються тільки типом значення, що повертається, породжують невизначеність.) Іншим обмеженням є те, що віртуальна функція повинна бути членом, а не другом класу, для якого вона визначена. Проте віртуальна функція може бути другом іншого класу. Хоча деструктор може бути віртуальним, але конструктор віртуальним бути не може.</p>
        <p>В силу відмінностей між перевантаженням звичайних функцій і перевизначенням віртуальних функцій будемо використовувати для останніх термін перевизначення (overriding).</p>
        <p>Якщо функція була оголошена як віртуальна, то вона і залишається такою незалежно від кількості рівнів в ієрархії класів, через які вона пройшла. Наприклад, якщо клас second_d отриманий з класу first_d, а не з класу Base, то функція who () залишиться віртуальної і буде викликатися коректна її версія.</p>
        <p>Якщо в похідному класі віртуальна функція не переважають, то тоді використовується її версія з базового класу.</p>
        <p>Треба мати на увазі, що характеристики успадкування носять ієрархічний характер. Щоб проілюструвати це, припустимо, що в попередньому прикладі клас second_d породжений від класу first_d замість класу Base. Коли функцію who () викликають, використовуючи покажчик на об'єкт типу second_d (в якому функція who () не визначалась), то буде викликана версія функції who (), оголошена в класі first_d, оскільки цей клас - найближчий до класу second_d. У загальному випадку, коли клас не переважають віртуальну функцію, С ++ використовує перше з визначень, яке він знаходить, йдучи від нащадків до предків.</p>
        </div>
    </div>
    <div id="footer">
       <div id="contacts"><center><h2>Контакти<hr></h2>
           <a href="http://www.facebook.com/zubykandriy" target="blank"><img src="images/Facebooklogo2.png" class="logo_of_contacts" alt="Facebook" title="Facebook"></a><br>  
           <a href="https://vk.com/zubyk.andriy" target="blank"><img src="images/vk2.png" class="logo_of_contacts" alt="Vk" title="Vk"></a></center>
       </div>
       <div id="other"><center><h2>IDE<hr></h2>
       <a href="https://www.visualstudio.com/ru/downloads/?rr=https%3A%2F%2Fwww.google.com.ua%2F" target="blank"><img src="images/VS.png" class="logo_of_other" alt="Visual Studio" title="Visual Studio"></a><br>
       <a href="https://www.qt.io/download" target="blank"><img src="images/Qt2.png" class="logo_of_other" alt="Qt Creator" title="Qt Creator"></a></center>
       </div>
       <div id="signature"><center><p>Зубик Андрій &copy; 2018<br><span class="hp"><img src="images/logo_c.svg"> Довідник С++/Qt <img src="images/logo_qt2.png"></span></p></center></div>
    </div>
 </div>
</body>
</html>