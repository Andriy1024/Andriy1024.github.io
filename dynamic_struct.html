<!DOCTYPE html>
<html>
<head>
    <title>C++/Qt</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="stylesheet" href="fonts/font.css">
    <link href="images/Qt2.png" rel="shortcut icon" type="image/x-icon">
</head>
<body>
 <div id="site">
    <div id="header">
        <div class="logo"><center><a href="C++.html"  name="C++" title="C++"><img src="images/logo_c.svg" class="logoimg"></a></center></div>
        <div class="logo2"><center><a href="Qt.html"  name="Qt" title="Qt"><img src="images/logo_qt.png" class="logoimg2"></a></center></div>
        <div class="title"><center><a href="index.html"  name="main" title="Головна"><img src="images/title.png" class="titleimg"></a></center></div>
        
    </div>
    <div id="content">
        <div id="menu3">
            <ul>
                <li><a href="type.html">Типи даних</a>
                </li>
                <li><a href="operators.html">Оператори й операції</a>
                </li>
                <li><a href="managing_structures.html">Керуючі структури</a>
                </li>
                <li><a href="cycle.html">Цикли</a>
                </li>
                <li><a href="functions.html">Функції</a>
                </li>
                <li><a href="standart_functions.html">Стандартні Функції</a>
                </li>
                <li><a href="array.html">Масиви []</a>
                </li>
                <li><a href="ptr.html">Вказівники *, Силки&</a>
                </li>
                <li><a href="string.html">Робота зі стрічками</a>
                </li>
                <li><a href="struct.html">Структури</a>
                </li>
                <li><a href="dynamic_struct.html">Динамічні Структури даних</a>
                </li>
                <li><a href="fstream.html">Робота з файлами(Fstream)</a>
                </li>
                <li><a href="template.html">Шаблони функцій</a>
                </li>
                <li><a href="clases.html">ООП Класи</a>
                </li>
                <li><a href="constructors.html">Конструктор і деструктор</a>
                </li>
                <li><a href="peregruzka.html">Перегрузка операцій</a>
                </li>
                <li><a href="nasliduvanya.html">Наслідування</a>
                </li>
                <li><a href="virtual.html">Віртуальні функції</a>
                </li>
                <li><a href="exception.html">Винятки</a>
                </li>
                <li><a href="stl.html">STL</a>
                </li>
            </ul>
       </div>
        <div id="menu4">
            <ul>
                <li><a href="qt_creator.html">Qt Creator</a>
                </li>
                <li><a href="Widgets.html">Віджети та компонування</a>
                </li>
                <li><a href="comp.html">Класи компонування</a>
                </li>
                <li><a href="Modul.html">Модулі Qt</a>
                </li>
                <li><a href="qt_designer.html">Знайомство з Qt Designer</a>
                </li>
                <li><a href="signals.html">Сигнали и слоти</a>
                </li>
                <li><a href="mainwindow.html">Класи главного вікна</a>
                </li>
                </li>
                <li><a href="dialog.html">Діалогові вікна</a>
                </li>
                <li><a href="Modal.html">Модальні немодальні вікна</a>
                </li>
                <li><a href="Menu.html">Створення меню в Qt</a>
                </li>
                <li><a href="qfile.html">Робота з файлами</a>
                </li>
                <li><a href="qdata.html">Клас дати QDate</a>
                </li>
                <li><a href="qtime.html">Клас часу QTime</a>
                </li>

                <li><a href="conteiner.html">Контейнери в Qt</a>
                </li>
                <li><a href="iterator.html">Ітератори</a>
                </li>
                <li><a href="foreach.html">Конструкція foreach</a>
                </li>
                <li><a href="Webkit.html">QtWebKit Guide</a>
                </li>
                <li><a href="sql.html">Модуль QtSql</a>
                </li>
                <li><a href="paint.html">Система малювання</a>
                </li>
                <li><a href="test.html">Тестування в Qt</a>
                </li>
            </ul>
       </div> 
        <div id="wrapper">
            <center><h1>Динамічні структури даних</h1></center>
        <br>
        <center><h1>Однобічно зв'язаний список</h1></center>
        <p>Однозв'язний список — вид зв'язаного списку, який складається з вузлів, кожен з яких містить у собі данні (інформаційну частину) та посилання на наступний вузол.</p>
        <p>Найчастіше вузлом списку вважають структурний тип (структуру), який зберігає у собі певну інформаційну частину (іншу структуру або тип даних) та посилання (вказівник) на наступний вузол у списку. Список має «голову» head, тобто вказівник на початок списку та інколи має кінець tail, проте найчастіше його не використовують.</p>
        <h2>Переваги списків над масивами:</h2>
        <p>1. Можливість додавати вузол у кінець списку. Масив має статичний розмір, і, якщо, вільного місця там немає, доведеться створювати масив більшого розміру, копіювати у нього елементи «старого» масиву і тільки після цього додавати новий елемент</p>
        <p>2. Можливість видаляти вузол і звільнювати пам'ять, яку він займав. У масиві можна лише зсунути елементи і розглядати його, як масив меншого розміру. Пам'ять при цьому не звільняється.</p>
        <p>3. Можливість вставляти вузол у середину списку. При умові, що масив не заповнений до кінця, можна «розсунути» елементи і вставити між ними необхідний. Якщо ж масив повний — доведеться створювати новий масив більшого розміру, копіювати елементи і вставляти новий.</p>
        <h2>Недоліки списків перед масивами:</h2>
        <p>1. Відсутність поіндексного доступу до елементів списку</p>
        <p>2. Зайвий час на прохід по списку для пошуку/видалення/додавання елементу у кінець</p>
        <p>3. Використання більшого об'єму пам'яті за рахунок покажчиків на наступний вузол</p>
        <h2>Операції зі списками: </h2>
        <h2>Додати вузол у кінець списку</h2>
        <p>Для того, щоб додати вузол А у кінець списку, треба знайти останній вузол В у цьому списку, заповнити інформаційну частину вузла А і вказівнику вузла А присвоїти NULL, і «приєднати» його до останнього вузла у списку, тобто до вузла В.</p>
        <h2>Додати вузол у початок списку</h2>
        <p>Для того, щоб додати вузол А у початок списку, потрібно заповнити інформаційну частину вузла А, вказівник А направити на голову head списку і зробити цей вузол головою.</p>
        <h2>Видалити заданний вузол зі списку</h2>
        <p>Для того, щоб видалити необхідний вузол, потрібно послідовно перебирати вузли, запам'ятовуючи попередній вузол В. Коли необхідний вузол А буде знайдено, потрібно вказівник «попередника» (тобто вузла В) зв'язати з наступним вузлом (тим, що йде після вузла А) і видалити вузол А.</p>
        <h2>Реалізація списку у С++</h2>
        <p><ex class="ex">&nbsp;&nbsp; struct Node &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; int value; // певна інформативна частина &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Node * next; // вказівник (pointer) на наступну структуру-вузол у списку &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Node * head = NULL; // вказівник на голову списку, спочатку він нікуди не вказує, бо список порожній &nbsp;&nbsp;</ex></p>
        <h2>Реалізація функції додавання у кінець списку</h2>
        <p><ex class="ex">&nbsp;&nbsp; void addToEnd(int v) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Node * n; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; if (!head) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; head = new Node; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; head->value = v; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; head->next = NULL; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; return; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; else &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; n = head; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; while (n->next) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp; n = n->next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Node * newNode = new Node; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; newNode->value = v; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; newNode->next = NULL; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; n->next = newNode; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; return; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <h2>Реалізація функції додавання у початок списку</h2>
        <p><ex class="ex">&nbsp;&nbsp; void addToBegin(int v) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Node * n = new Node; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; n->value = v; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; n->next = head; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; head = n; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <h2>Реалізація функції видалення певного вузла</h2>
        <p><ex class="ex">&nbsp;&nbsp; void deleteNode(Node * n) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Node * k = head; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; if (head == n) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp; head = n->next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp; delete n; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp; return; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; while (k->next != n) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp; k = k->next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; k->next = n->next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; delete n; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <h2>Реалізація функції пошуку вузла за інформаційною частиною</h2>
        <p><ex class="ex">&nbsp;&nbsp; Node * find(const int v) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Node * n = head; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; while (n) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp; if (n->value == v) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return n;&nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp;&nbsp;&nbsp; n = n->next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; return NULL; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <br>
        <center><h1>Стек</h1></center>
        <p>Стек (англ. stack — «стос, стіс») в інформатиці та програмуванні — різновид лінійного списку, структура даних, яка працює за принципом (дисципліною) «останнім прийшов — першим пішов» (LIFO, англ. last in, first out). Всі операції (наприклад, видалення елементу) в стеку можна проводити тільки з одним елементом, який знаходиться на верхівці стеку та був введений в стек останнім.</p>
        <p>Стек можна розглядати як певну аналогію до стопки тарілок, з якої можна взяти верхню, і на яку можна покласти верхню тарілку (інша назва стеку — «магазин», за аналогією з принципом роботи магазину в автоматичній зброї).</p>
        <h2>Операції зі стеком</h2>
        <p>push - («заштовхнути елемент»): елемент додається в стек та розміщується в його верхівці. Розмір стеку збільшується на одиницю. При перевищенні розміру стека граничної величини, відбувається переповнення стека (англ. stack overflow).</p>
        <p>pop - («виштовхнути елемент»): отримує елемент з верхівки стеку. При цьому він видаляється зі стеку і його місце в верхівці стеку займає наступний за ним відповідно до правила LIFO, а розмір стеку зменшується на одиницю. При намаганні «виштовхнути» елемент з вже пустого стеку, відбувається ситуація «незаповнення» стеку (англ. stack underflow).</p>
        <p>Кожна з цих операцій зі стеком виконується за фіксований час O(1) і не залежить від розміру стеку.</p>
        <p>Додаткові операції (присутні не у всіх реалізаціях стеку):</p>
        <p>isEmpty: перевірка наявності елементів в стеку; результат: істина (true), коли стек порожній.</p>
        <p>isFull: перевірка заповненості стека. Результат: істина, коли додавання нового елементу неможливе.</p>
        <p>clear: звільнити стек (видалити усі елементи).</p>
        <p>top: отримати верхній елемент (без виштовхування).</p>
        <p>size: отримати розмір (кількість елементів) стека.</p>
        <h2>Організація в пам'яті комп'ютера</h2>
        <p>Стек може бути організований як масив або множина комірок в певній області комп'ютера з додатковим зберіганням ще й вказівника на верхівку стека. Заштовхування першого елемента в стек збільшує адресу вказівника, виштовхування елементу зменшує її. Таким чином, адреса вказівника завжди відповідає комірці масиву, в якій зараз знаходиться верхівка стеку.</p>
        <p>Багато процесорів ЕОМ мають спеціалізовані регістри, які використовуються як вказівники на верхівку стеку, або використовують деякі з регістрів загального вжитку для цієї спеціальної функції в певних режимах адресації пам'яті.</p>
        <h2>Реалізація стеку у С++</h2>
        <p><ex class="ex">&nbsp;&nbsp; struct Stek &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; int key; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Stek *next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; }; &nbsp;&nbsp;</ex></p>
        <h2>Реалізація функції push</h2>
        <p><ex class="ex">&nbsp;&nbsp; void push(Stek **next, int d) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Stek *pv = new Stek; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; pv->key = d; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; pv->next = *next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; *next = pv; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        <h2>Реалізація функції pop</h2>
        <p><ex class="ex">&nbsp;&nbsp; int pop(Stek **next) &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; { &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; int temp = (*next)->key; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; Stek *pv = (*next); &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; (*next) = (*next)->next; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; delete pv; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; return temp; &nbsp;&nbsp;</ex></p>
        <p><ex class="ex">&nbsp;&nbsp; } &nbsp;&nbsp;</ex></p>
        </div>
    </div>
    <div id="footer">
       <div id="contacts"><center><h2>Контакти<hr></h2>
           <a href="http://www.facebook.com/zubykandriy" target="blank"><img src="images/Facebooklogo2.png" class="logo_of_contacts" alt="Facebook" title="Facebook"></a><br>  
           <a href="https://vk.com/zubyk.andriy" target="blank"><img src="images/vk2.png" class="logo_of_contacts" alt="Vk" title="Vk"></a></center>
       </div>
       <div id="other"><center><h2>IDE<hr></h2>
       <a href="https://www.visualstudio.com/ru/downloads/?rr=https%3A%2F%2Fwww.google.com.ua%2F" target="blank"><img src="images/VS.png" class="logo_of_other" alt="Visual Studio" title="Visual Studio"></a><br>
       <a href="https://www.qt.io/download" target="blank"><img src="images/Qt2.png" class="logo_of_other" alt="Qt Creator" title="Qt Creator"></a></center>
       </div>
       <div id="signature"><center><p>Зубик Андрій &copy; 2018<br><span class="hp"><img src="images/logo_c.svg"> Довідник С++/Qt <img src="images/logo_qt2.png"></span></p></center></div>
    </div>
 </div>
</body>
</html>